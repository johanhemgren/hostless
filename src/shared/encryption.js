const{createHash,createCipheriv,createDecipheriv,randomBytes}=require("crypto"),{getDnsPasswordString}=require("./getDnsPasswordString"),{ENCRYPTION_ALGORITHM,IV_LENGTH}=require("./constants"),generatePassword=(t=32)=>{const r="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'()*+,-./:;<>?@[]^_`{|}~";return Array(t).fill(0).reduce(e=>`${e}${r[parseInt(Math.random()*r.length)]}`,"")},setPassword=t=>t&&t.trim()!==""&&t.length>=8?t:generatePassword(32),getHash=async(t,r=null)=>{if(!t)return null;const n=createHash("sha256"),e=r!=null?r:await getDnsPasswordString(t);return n.update(process.env.HASH+t+e),n.digest("hex").substr(0,32)},encryptData=async(t,r,n)=>{if(!t||!r)return null;const e=randomBytes(IV_LENGTH),a=await getHash(r,n),c=createCipheriv(ENCRYPTION_ALGORITHM,Buffer.from(a),e);let s=c.update(t);return s=Buffer.concat([s,c.final()]),`${e.toString("hex")}:${s.toString("hex")}`},decryptString=async(t,r)=>{const n=await getHash(r);if(!n)return null;const e=t.split(":"),a=Buffer.from(e.shift(),"hex"),c=Buffer.from(e.join(":"),"hex"),s=createDecipheriv(ENCRYPTION_ALGORITHM,Buffer.from(n),a);let o=s.update(c);return o=Buffer.concat([o,s.final()]),o.toString()};exports.setPassword=setPassword,exports.encrypt=encryptData,exports.decrypt=decryptString;
